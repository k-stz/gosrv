<!doctype html>
<html class="no-js" lang="">
<head>
  <meta charset="UTF-8">
  <title>SOP Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/htmx.org@2.0.6/dist/htmx.min.js" integrity="sha384-Akqfrbj/HpNVo8k11SXBb6TlBWmXXlYQrCSqEWmyKJe+hDm3Z/B2WVG4smwBkRVm" crossorigin="jojo"></script>
  <script>
    x = new XMLHttpRequest();
    // make GET request to endpoint replacing DOM elemet with 'id' with response payload
    myReplacer = (endpoint, id) => { 
        console.log("myReplacer called!");
        x.open("GET", endpoint);
        x.send();
        // here we basically do what htmx does with: 
        // hx-get="/echo", hx-trigger=load, hx-target="#mydiv" does
        x.onload = function() {
            console.log("xmlhttprequest finished, response text is:", x.responseText);
            responseText = x.responseText
            document.getElementById(id).innerHTML = responseText
        }
    }
    // finally trigger the a.send() on click
    /**
    * Replaces the content of an element with HTML from an endpoint.
    * @param {string} endpoint - The URL to fetch HTML from.
    * @param {string} id - The ID of the target element.
    */
    const myFetchReplacer = async (endpoint, id) => {
        console.log("myFetchReplacer called! With endpoint\=" + endpoint + " id\="+id);
        try {
            // await blocks till headers are received - not body, that's what response.text() does!
            const response = await fetch(endpoint);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            // awaits till body is received!
            const html = await response.text();

            const target = document.getElementById(id);
            if (target) {
                // I don't understand at all how sanitization is done in this line
                target.innerHTML = html;
            } else {
                console.error(`Element with id "${id}" not found.`);
            }
         } catch (error) {
            console.log("myFetchReplacer failed with:", error)
         }
    }
  </script>
  <!-- extract headers -->
  <script>
  async function fetchExample() {
  const url = 'http://localhost:5000/httpbin';

  try {
    // 1. Make the fetch request
    const response = await fetch(url);

    // 2. Check if the request was successful (status 200-299)
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    // 3. Extract Headers
    console.log('--- Response Headers ---');
    // Headers object allows iteration and getting specific headers
    for (let [key, value] of response.headers) {
      console.log(`${key}: ${value}`);
    }
    console.log('Content-Type:', response.headers.get('Content-Type')); // Get specific header

  const data = await response.text();
  console.log('--- Response Body ---');
  console.log(data);

  cookie = response.headers.getSetCookie('Cookie')

  if (cookie.length > 0) {
    console.log("GOT COOOKIE!!!! Cookie=", cookie)
  } else {
    console.log("No cookie found (cookie.length < 0). Cookie:", cookie)

  }

  } catch (error) {
    console.error('Fetch Error:', error);
  }
}

fetchExample();

  </script>

  <link rel="stylesheet" href="styles.css">
</head>
   <p>Add button that will on click run a XHR function</p>
   <button hx-get="/json" hx-trigger="click" hx-target="#display1">
     Run htmx hx-get=/json
   </button>
   <div id="display1"> Display 1  </div>
   <br>

   <button onclick="myReplacer('/echo?q=ajax-powered-by-XMLHttpRequest!', 'display2')">
      Run XHR myReplacer('display2')
    </button>
    <div id="display2">
      Display 2
    </div>

    <button onclick="myFetchReplacer('/echo?q=ajax-powered-by-Fetch-API!!', 'display2-fetch')">
      Run Fetch API implementation  myFetchReplacer('/echo?q=ajax-powered-by-XMLHttpRequest!', 'display2-fetch')
    </button>
    <div id="display2-fetch">
      Display 2 Fetch API example
    </div>


<h1>SOP legal crossings</h1>
<p>SOP prevents loading content from another website. But that's not true you might think, we see websites load external content all the time. For example an image:  </p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/500px-Tux.svg.png" style="width: 100px">

<p>That is because SOP aims to prevent scripts from access cross origin </p>
<p>Run this site both on two ports, this already counts as a differnt origin. And now try to press these buttons.</p>
<p>The first button will try to issue a http request to /json returning simple json response. While the second button calls the same endpoint but on another orign localhost:5050/json, violating the SOP. </p>

<p>One of trigger a violation of SOP, <b>check out the browser devtool debug console!</b></p>
   <button onclick="myReplacer('/json' , 'display3')">
     Run XHR myReplacer('/json', 'display3')
   </button>
   <br><b>Result:</b><br><div id="display3">
     Display 3
   </div>
   <br>
   <button onclick="myReplacer('http://localhost:5050/json' , 'display4')">
     Run XHR myReplacer('http://localhost:5050/json', 'display4')
   </button>
   <br><b>Result:</b><br><div id="display4">
     Display 4
   </div>


<h1>CORS examples</h1>
<p>CORS (Cross-origin resource sharing), is a mechanism to relax the CORS policy. A website response with CORS specific headers (Access-Control-Allow-Origin: *) to indicate that it allows fetching code from a different origin.</p>

   <p> using /json?cors=true, will set the CORS response header. This effectivly allows clients loading code from that webserver. Thus yielding a Reposne for replacement:</p>
   <button onclick="myReplacer('http://localhost:5050/json?cors=true' , 'display5')">
     Run XHR myReplacer('http://localhost:5050/json?cors=true', 'display5')
   </button>
   <br><b>Result:</b><br><div id="display5">
     Display 5
   </div>


<br>
<button onclick="fetchExample()"> Fetch Example log headers+body
</button>
<p>When you inspect the http-request with wireshark that the fetchExample call will do, you can see that it contains the "Cookie: some-cookie" header! But there is no way in JavaScript to extract that header from the client-side, this is expressly removed.  </p>
<p>Check devtools console for the output</p>

<br>
<h1>REST API example</h1>
<p>What about calling a server providing a rest api? Following the logic of SOP, that is a different Origin, and thus to use it in the client-side javascript we would have to get a CORS header to do a fetch operation:</p>
<p>TODO improve this example, this endpoint is to the kubernetes-api returning a simple json localhost:8001/api Better allow to make the request to an input field, so we can just enter endpoint dynamically int there</p>

   <p> using /json?cors=true, will set the CORS response header. This effectivly allows clients loading code from that webserver. Thus yielding a Reposne for replacement:</p>
<p>
  using /json?cors=true, will set the CORS response header. This effectively allows clients loading code from that webserver.
</p>

<p>Kubenetes API CORS headers will show up when you make a request to it in the browser, in this case we got: Access-Control-Allow-Origin	http://localhost:5000 </p>
<p>Interesting: When you make a curl request to the endpoint it will NOT return the CORS header, as per the spec the kbuernetes-API only does that when you pass an Origin header along with it. So only this request will show the CORS headers:</p>
Hint to show CORS header with curl pass Origin header: <code>curl http://localhost:8001/api -v -H "Origin: http://localhost:5050"</code>
<br>
<label>
  Endpoint:
  <input
    type="text"
    id="endpointInput"
    value="http://localhost:5050/json?cors=true "
    style="width: 420px;"
  />
</label>

<br><br>

<button
  onclick="myReplacer(document.getElementById('endpointInput').value, 'display6')"
>
  Run XHR
</button>

<br><b>Result:</b><br>

<div id="display6">
  Display 6
</div>



</body>
</html>
